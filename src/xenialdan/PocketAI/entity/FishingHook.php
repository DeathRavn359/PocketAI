<?php

declare(strict_types=1);

namespace xenialdan\PocketAI\entity;

use pocketmine\block\Water;
use pocketmine\entity\Entity;
use pocketmine\event\entity\EntityDamageByChildEntityEvent;
use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\event\entity\ProjectileHitEvent;
use pocketmine\math\Vector3;
use pocketmine\network\mcpe\protocol\EntityEventPacket;
use pocketmine\Player;
use xenialdan\PocketAI\EntityProperties;
use xenialdan\PocketAI\entitytype\AIProjectile;
use xenialdan\PocketAI\Loader;

class FishingHook extends AIProjectile{
	const NETWORK_ID = self::FISHING_HOOK;

	/** @var Vector3 */
	public $direction = null;
	/** @var bool */
	public $hooked = false;

	protected $gravity = 0.1;
	protected $drag = 0.05;

	public function initEntity(){
		$this->setEntityProperties(new EntityProperties("entities/fishing_hook", $this));
		parent::initEntity();
		$this->setDataProperty(34, Entity::DATA_TYPE_FLOAT, 1);
		$this->setDataProperty(35, Entity::DATA_TYPE_FLOAT, 1);
		$this->setDataProperty(36, Entity::DATA_TYPE_FLOAT, 1);
	}

	public function getName(): string{
		return "Fishing Hook";
	}

	public function isHooked(){
		return $this->hooked;
	}

	public function attack(EntityDamageEvent $source){
		if($source->getCause() !== EntityDamageEvent::CAUSE_ENTITY_ATTACK){
			$this->close();
			//applyDamage?
			Loader::setHook($this->getOwningEntity(), null);
		}
		parent::attack($source); // TODO: Change the autogenerated stub
	}

	public function onCollideWithEntity(Entity $entity){
		$this->server->getPluginManager()->callEvent(new ProjectileHitEvent($this));

		$damage = $this->getResultDamage();

		if ($this->getOwningEntity() === null){
			$ev = new EntityDamageByEntityEvent($this, $entity, EntityDamageEvent::CAUSE_PROJECTILE, $damage);
		} else{
			$ev = new EntityDamageByChildEntityEvent($this->getOwningEntity(), $this, $entity, EntityDamageEvent::CAUSE_PROJECTILE, $damage);
		}

		$entity->attack($ev);

		$this->hadCollision = true;

		Loader::setEntityLink($ev->getDamager(), $ev->getEntity());
	}

	protected function applyGravity(){
		if ($this->isInAir() && !$this->isCollidedHorizontally){
			parent::applyGravity();
			return;
		}
		$block = $this->level->getBlock($this);
		$collided = $this->isCollided;

		if ($this->isActuallyInsideOfWater()){
			$this->motionY += $this->gravity;
			$this->motionY *= 0.2;
			$this->drag = $block->getFrictionFactor();
		}

	}

	public function isActuallyInsideOfWater(): bool{
		$block = $this->level->getBlock($this);
		if ($block instanceof Water){
			$f = $block->y + (1 - $block->getFluidHeightPercent());
			if (($this->y + $this->getEyeHeight()) <= $f){
				return true;
			}
		}
		return false;
	}

	public function entityBaseTick(int $tickDiff = 1): bool{
		if ($this->isInsideOfWater()){
			if (mt_rand(0, 300) === 0){
				$this->hooked = true;
				$pk = new EntityEventPacket();
				$pk->event = EntityEventPacket::FISH_HOOK_HOOK;//have fish on hook
				$pk->entityRuntimeId = $this->getId();
				$this->getLevel()->getServer()->broadcastPacket($this->getViewers(), $pk);
				/** @var Player $owner */
				if (($owner = $this->getOwningEntity()) instanceof Player)
					$owner->sendMessage("FISH_HOOK_HOOK");
			}
			if (mt_rand(0, 300) === 0){
				$pk = new EntityEventPacket();
				$pk->event = EntityEventPacket::FISH_HOOK_POSITION;//water particles before hooking
				$pk->entityRuntimeId = $this->getId();
				$this->getLevel()->getServer()->broadcastPacket($this->getViewers(), $pk);
				/** @var Player $owner */
				if (($owner = $this->getOwningEntity()) instanceof Player)
					$owner->sendMessage("FISH_HOOK_POSITION");
			}
			#EntityEventPacket::FISH_HOOK_BUBBLE;//unknown
			#EntityEventPacket::FISH_HOOK_TEASE;//unknown
		}
		return parent::entityBaseTick($tickDiff); // TODO: Change the autogenerated stub
	}
}
